*   代码区：存放函数体的二进制代码，由操作系统进行管理的
-   全局区：存放全局变量和静态变量以及常量
-   栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
-   堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收
# 堆区
由程序员分配释放,若程序员不释放,程序结束时由操作系统回收

​ 在C++中主要利用new在堆区开辟内存
例:
```C++
int* func()
{
	int* a = new int(10);
	return a;
}

int main() {

	int *p = func();

	cout << *p << endl;
	cout << *p << endl;
    
	system("pause");

	return 0;
}
```
 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==

​ 语法： `new 数据类型`

​ 利用new创建的数据，会返回该数据对应的类型的指针  

new 数据类型 ( ),括号内的值是对该内存空间要赋的初值,如果不需要,则不需加括号
例二
```C++
//堆区开辟数组
int main() {

	int* arr = new int[10];

	for (int i = 0; i < 10; i++)
	{
		arr[i] = i + 100;
	}

	for (int i = 0; i < 10; i++)
	{
		cout << arr[i] << endl;
	}
	//释放数组 delete 后加 []
	delete[] arr;

	system("pause");

	return 0;
}

```
# 引用
* 作用: 给变量起别名
* 实质:一个指针常量(如int * const p),指向被引用变量对应的地址 ,在需要解引用时,编译器自动对其解引用
* 语法： `数据类型 &别名 = 原名`
* 示例:
  ```C++
  int main() {

	int a = 10;
	int &b = a;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	b = 100;

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	system("pause");

	return 0;
}
```
**注意事项:**
-   引用必须初始化
-   引用在初始化后，不可以改变(引用不能改变,只能指向初始化时对应变量,但变量的值可以改变)，创建后不能改变所指变量,但可以由引用修改其值
示例：
```C++
int main() {

	int a = 10;
	int b = 20;
	//int &c; //错误，引用必须初始化
	int &c = a; //一旦初始化后，就不可以更改
	c = b; //这是赋值操作，不是更改引用

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	cout << "c = " << c << endl;

	system("pause");

	return 0;
}
```
**引用作为函数参数**
例:
```C++
void mySwap03(int& a, int& b) {
	int temp = a;
	a = b;
	b = temp;
}
```
注:
* int&是类型声明,声明了int型的引用,a是形参名
* 将变量传值给引用,对引用改变后,相当于对原变量改变,即引用作为函数参数,相当于指针,但引用的语法更简单
* 引用作为函数返回值不能是局部变量的引用
* 不想改变变量,用const声明引用
# 作用域
在C++中，变量的作用域可分为局部作用域和全局作用域。在函数内部声明/定义的变量叫局部变量，局部变量的作用域仅限于函数内部；而在所有函数外部声明的变量叫全局变量，全局变量的作用域从定义处开始到文件结束。

此外，C++还有语句作用域、类作用域、命名空间作用域和文件作用域34。其中，语句作用域是指在一个语句块内部定义的变量只在该语句块内有效；**类作用域是指在类定义中定义的变量只能被该类的成员函数访问；命名空间作用域是指在命名空间中定义的变量只能被该命名空间中的函数访问**；文件作用域是指在文件中定义的变量只能被该文件中的函数访问

作用域符号::
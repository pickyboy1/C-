在C++中，==`extern`==是一个关键字，用于声明一个外部变量或函数，以便在当前文件或其他文件中使用。

1. 外部变量的声明：在一个源文件中，如果你想使用另一个源文件中定义的全局变量，你需要在当前文件中使用`extern`来声明该变量。
2. 外部函数不必要,包含相应头文件便可
在多个源文件的大型项目中，显式使用`extern`来声明外部变量和函数可以增强代码的可读性和维护性。避免重复定义,保持全局变量唯一性


==static==
1.静态变量（Static Variables）：**当`static`用于函数内部的局部变量时，它使该变量成为一个静态变量。静态局部变量在函数执行时只初始化一次，而不会在每次函数调用时都重新初始化**.这使得静态变量在多次函数调用之间保持其值不变。
```cpp
#include <stdio.h>

void counter(void) {
  static int count = 1;  // 只初始化一次
  printf("%d\n", count);
  count++;
}

int main(void) {
  counter();  // 1
  counter();  // 2
  counter();  // 3
  counter();  // 4
}
```
2.静态全局变量（Static Global Variables）：当`static`用于全局变量时，它使该变量的作用域限制在声明它的源文件中。其他源文件无法访问该变量，因此它对整个程序是隐藏的。

void指针,只指示内存地址,不指示类型,可与任何类型指针互相转化后再使用
void 指针的重要之处在于，很多内存相关函数的返回值就是 void 指针，只给出内存块的地址信息

==malloc==
`malloc()`函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件`stdlib.h`。

```c
void* malloc(size_t size)
```

它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个 void 指针，指向分配好的内存块。这是非常合理的，因为`malloc()`函数不知道，将要存储在该块内存的数据是什么类型，所以只能返回一个无类型的 void 指针。

可接受变量作为参数,用于实现动态分配内存,返回值为内存区域的void之分,一般要进行显式的强制类型转换,增强可读性

<还是new好用>

==free==
`free()`用于释放`malloc()`函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存块会一直占用到程序运行结束。该函数的原型定义在头文件`stdlib.h`里面。

```c
void free(void* block)
```

上面代码中，`free()`的参数是`malloc()`返回的内存地址。下面就是用法实例。

通常,在一些临时变量或函数里谁用malloc创建变量的话,临时变量或函数销毁后,相应变量不会销毁,直到程序结束时才销毁,造成额外开销,通常要自行free掉

==内存操作函数==
头文件string.h
## memcpy()

`memcpy()`用于将一块内存拷贝到另一块内存。
```c
void* memcpy(
  void* restrict dest, 
  void* restrict source, 
  size_t n
);
```
参数一是目标地址指针,参数二.....,参数三是拷贝的字节数
目标区域与原区域不能有重叠部分
## memmove()

`memmove()`函数用于将一段内存数据复制到另一段内存。它跟`memcpy()`的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内容会被更改；如果没有重叠，它与`memcpy()`行为相同。
```cpp
void* memmove(
  void* dest, 
  void* source, 
  size_t n
);
```
`memmove`函数的操作过程如下：

1. 检查目标内存区域和源内存区域是否有重叠。如果有重叠，`memmove`函数会选择一种安全的复制方式，确保数据正确复制，即使目标区域在源区域之前或之后。
    
2. 根据重叠情况，选择正确的复制方式：
    
    - 如果目标区域在源区域之前（不重叠），则从源区域的起始位置开始，将数据复制到目标区域。
    - 如果目标区域在源区域之后（不重叠），则从源区域的起始位置开始，将数据复制到目标区域。
    - 如果目标区域与源区域有重叠，则从源区域的末尾位置开始，逆向复制数据到目标区域，确保数据正确复制，不会覆盖源区域的数据。
3. 返回目标内存区域的指针，指向复制后的数据。
    

由于`memmove`函数处理了内存区域的重叠情况，因此在涉及可能存在重叠的内存复制操作时，建议使用`memmove`函数，以确保数据的正确复制。对于没有内存重叠的情况，`memcpy`函数可能会更高效。

**memcmp**
```cpp
int memcmp(
  const void* s1,
  const void* s2,
  size_t n
);
```
实现与strcmp相同,循环结束判断是根据n来,而不是\0,可以用于包含\0的内存的比较,返回值是s1指向字节值与s2指向字节值的差

==预处理相关==
首先介绍重复加载:
头文件的重复加载通常是指在C/C++程序中多次包含相同的头文件。这可能会在编译过程中产生一些问题和错误，需要注意避免。
1. 重定义错误：如果头文件中定义了变量、常量、函数或类等，多次包含会导致重复定义的错误。
    
2. 编译时间增加：多次包含头文件会导致编译时间增加，因为编译器需要多次处理相同的头文件内容。
为了避免头文件的重复加载，可以采取以下措施：

1. 使用预处理器指令：在头文件中使用预处理器指令来防止重复加载。可以使用条件编译指令如 `#ifndef`、`#define` 和 `#endif` 来包裹头文件内容，确保只有在第一次包含时才会加载。
   ```cpp
   // 在头文件中使用条件编译指令
   \#ifndef MY_HEADER_H
   \#define MY_HEADER_H
   
   // 头文件的内容
   
   \#endif
   ```
此处只介绍预处理指令

**预处理指令**
C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。
预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后，执行`#`开头的预处理指令。

- #define 宏指令,略
  \#运算符
  ```cpp
 #define STR(x) #x
  ```
  代码替换STR(x)为x,\#号用于指示x的类型为字符串2
- #undef 用于取消已用\#define定义的宏,使**后续代码**中相关宏失效,用于限制宏的作用域
- #include 用于编译时将其它源码文件加入到当前文件
  ```cpp
  // 形式一
  \#include <foo.h> // 加载系统提供的文件
  // 形式二
  \#include "foo.h" // 加载用户提供的文件
  ```
  即用户自己写的文件加载要用双引号
  - ==\#if....#endif,==
    `#if`后面的判断条件，通常是一个表达式。如果表达式的值不等于`0`，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。
    `#if...#endif`之间还可以加入`#else`指令，用于指定判断条件不成立时，需要编译的语句。
    ```c
    \#define FOO 1
    
    \#if FOO
    printf("defined\n");
    \#else
    printf("not defined\n");
    \#endif
    ```
    如果有多个判断条件，还可以加入`#elif`命令。
    ```c
    #if HAPPY_FACTOR == 0
     printf("I'm not happy!\n");
     #elif HAPPY_FACTOR == 1
     printf("I'm just regular\n");
     #else
     printf("I'm extra happy!\n");
     #endif
     ```
- ==\#ifdef...#endif==
  `#ifdef` 指令用于检查一个宏是否已经被定义，如果宏已定义，则编译后续的代码块。`#endif` 指令用于结束条件编译块。
  示例：
  ```cpp
  \#define DEBUG  // 定义一个宏 DEBUG  
  \#ifdef DEBUG     
  // 这里是在宏 DEBUG 已定义时需要编译的代码块     
  printf("Debug mode is enabled.\n");     
  // 其他调试相关的代码 
  #endif`
  ```
- `#ifdef`指令，等同于==`#if defined`==。defined运算符 接宏,若宏已定义,返回1,未定义返回0
- ==\#ifndef...#endif==
  如果宏未定义,则执行相应内容
  `#ifndef`常用于防止重复加载。举例来说，为了防止头文件`myheader.h`被重复加载，可以把它放在`#ifndef...#endif`里面加载。
  ```cpp
 \#ifndef MYHEADER_H
 \#define MYHEADER_H
  \#include "myheader.h"
  \#endif
  ```
  上面示例中，宏`MYHEADER_H`对应文件名`myheader.h`的大写。只要`#ifndef`发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏`MYHEADER_H`，防止被再次加载。


auto&register标识,基本没用,了解一下
auto声明的变量让编译器自行分配内存,但默认就是编译器自主分配,加不加auto都一样,
register声明的变量放寄存器,但到底放不放还是编译器自己决定,而有register声明的变量可能在寄存器,不能进行取地址操作,一般不用



const char* s = "Hello, world!";
加const不加const都一样,加const原因,显式的指示s是指向字符常量的指针,不能修改,修改后编译器会报错.


struct 结构占用的存储空间，不是各个属性存储空间的总和，而是最大内存占用属性的存储空间的倍数，其他属性会添加空位与之对齐。这样可以提高读写效率。

```c
struct foo {
  int a;
  char* b;
  char c;
};
printf("%d\n", sizeof(struct foo)); // 24
```

上面示例中，`struct foo`有三个属性，在64位计算机上占用的存储空间分别是：`int a`占4个字节，指针`char* b`占8个字节，`char c`占1个字节。它们加起来，一共是13个字节（4 + 8 + 1）。但是实际上，`struct foo`会占用24个字节，原因是它最大的内存占用属性是`char* b`的8个字节，导致其他属性的存储空间也是8个字节，这样才可以对齐，导致整个`struct foo`就是24个字节（8 * 3）。

多出来的存储空间，都采用空位填充
这种机制便于快速在struct结构体中定位到成员,因为每个成员相对偏移量都相同



- `\a`：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。
- `\b`：退格键，光标回退一个字符，但不删除字符。
- `\f`：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于`\v`。
- `\n`：换行符。
- `\r`：回车符，光标移到同一行的开头。
- `\t`：制表符，光标移到下一个水平制表位，通常是下一个8的倍数。
- `\v`：垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。
- `\0`：null 字符，代表没有内容。注意，这个值不等于数字0。

转义写法还能使用八进制和十六进制表示一个字符。

- `\nn`：字符的八进制写法，`nn`为八进制值。
- `\xnn`：字符的十六进制写法，`nn`为十六进制值。
  
位运算
  与(&)或(|)异或(^)取反(~)左移,右移
  算术左移逻辑左移一样,直接移,右侧补0
  算术右移,左侧补原来最高位
  逻辑右移用0补
  tips异或加密密码,将密码与加密秘钥key异或得加密密码,还可以不止一个key,取密码时再按顺序与key异或回去即得原密码


未赋值的数组元素,根据类型,一般默认赋0,\0,null等
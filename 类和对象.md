C++面向对象的三大特性为：==封装、继承、多态==
# 封装
封装是面向对象编程中的一个重要概念，==它指的是将数据和操作数据的函数（即类的成员函数）组合成一个整体，并对外部隐藏具体实现细节，只暴露必要的接口供其他代码使用。==封装是面向对象编程的三大特性之一，其意义如下：

1. **隐藏实现细节,保护数据安全性**：封装允许将类的内部数据和实现细节隐藏起来，只暴露有限的接口供外部访问。这样，其他代码只能通过公共的接口与类进行交互，而无法直接访问类的私有成员，避免数据被非法或错误使用,从而保护了数据的安全性和完整性。
    
2. **简化代码使用**：封装提供了一个高层次的接口，使得其他代码可以简单地使用类的功能，而无需关心类的具体实现细节。这样，代码的使用和维护变得更加方便，同时也降低了出错的可能性。
    
3. **提高代码的可维护性**：通过封装，类的内部实现可以被随意修改而不影响外部代码的使用。如果类的内部发生变化，==只需保持接口的稳定，而无需改动其他使用该类的代码。==这有助于减少代码的耦合性，使得程序更容易维护和扩展。
    
4. **促进代码复用**：封装可以将类的功能封装成独立的模块，这些模块可以在不同的地方进行复用。其他代码可以通过实例化类对象来复用类的功能，从而减少了代码的冗余和重复编写的情况。
# 类和对象
   **类（Class）**： 类是面向对象编程中的模板或蓝图，用于定义对象的属性和行为。它是一种用户自定义的数据类型，可以看作是一种抽象数据类型的扩展。类可以包含数据成员（也称为属性或字段）和成员函数（也称为方法）。数据成员用于存储对象的状态，成员函数用于定义对象的行为。
   
  **对象（Object)**： 对象是类的实例化，是类的一个具体实例。它是根据类的定义创建的一个具体数据单元，包含了类中定义的数据成员的值和可以调用的成员函数。可以将对象看作是类的变量，每个对象都有自己独立的状态和行为。
**语法：** `class 类名{ 访问权限： 属性 / 行为 };`

**访问权限**
类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限以类为单位,不是以对象为单位

访问权限有三种：

1.  public 公共权限
2.  protected 保护权限
	   protected 修饰的成员只能被类的成员函数、子类函数及友元函数访问，不能被其他任何访问，包括本身的类对象。protected 权限主要用于实现继承和多态，保护基类的成员不被外部修改，但又允许派生类对其进行扩展或重写,protect对外相当于private,但对朋友(友元),儿子(继承),又是public的
1.  private 私有权限
	[private权限的作用是实现数据隐藏，也就是保护类的内部数据不被外部修改或破坏。这是面向对象编程中封装的一个重要方面
	private权限成员,不能在类的定义外通过类名.成员对其访问或修改
	但可以在类外调用类中的函数,实现对私有成员的相关操作
	类的定义中,各种成员可互相访问,且对于函数成员,可直接使用所在对象成员,不需要传参.
	同一个类时,可以在一个对象中通过成员函数访问到另一个对象的成员.
例:
```C++
//三种权限
//公共权限  public     类内可以访问  类外可以访问
//保护权限  protected  类内可以访问  类外不可以访问
//私有权限  private    类内可以访问  类外不可以访问

class Person
{
	//姓名  公共权限
public:
	string m_Name;
	void print_info(){
	cout<<m_Name<<" "<<m_Car<<" "<<m_Password<<endl;
	}

	//汽车  保护权限
protected:
	string m_Car;

	//银行卡密码  私有权限
private:
	int m_Password;

public:
	void func()
	{
		m_Name = "张三";
		m_Car = "拖拉机";
		m_Password = 123456;
	}
};

int main() {

	Person p;
	p.m_Name = "李四";
	//p.m_Car = "奔驰";  //保护权限类外访问不到
	//p.m_Password = 123; //私有权限类外访问不到
	p.print_info();//可由成员函数简介访问
	system("pause");

	return 0;
}//三种权限
```
在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**


# 实例化
* 本质:创建类的一个实例,即类的一个对象,实例化一个类,就是**为类的对象分配一个内存空间,并调用构造函数来初始化对象.**
* 实例化的实现主要包括以下方式
	**栈上实例化**： 在函数内部或代码块中声明一个类对象，对象的生命周期与所在的函数或代码块相同，当函数或代码块执行完毕时，对象会自动销毁。
	**堆上实例化**： 使用 `new` 运算符在堆上分配内存，并创建类对象，对象的生命周期需要手动管理，即需在适当的时候通过 `delete` 运算符释放内存。
	**全局对象**： 在全局作用域（在所有函数之外）实例化一个类对象，全局对象的生命周期从程序开始到结束，全局对象会在程序结束时自动销毁。
	**静态实例化**： 在类定义中使用 `static` 关键字声明一个静态成员变量，静态成员变量属于类本身而不是对象，可以通过类名直接访问，无需实例化对象


# 对象的初始化和清理
1.构造函数和析构函数
	c++利用了**构造函数**和**析构函数**来对对象初始化和清理，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。
	对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。
2.
* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译自动调用，无须手动调用。
-  析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。
3.**构造函数语法：**`类名(){}`

1.  构造函数，没有返回值也不写void
2.  函数名称与类名相同
3.  构造函数可以有参数，因此可以发生重载
4.  程序在实例化对象时候会自动调用构造，无须手动调用,而且只会调用一次
5. 如果一个类有多个构造函数，那么每个构造函数都会被调用，但是只有一个构造函数会被调用来创建对象。这个构造函数的选择取决于你在创建对象时使用的参数类型和数量。如果你没有指定参数，则会调用默认构造函数

**析构函数语法：** `~类名(){}`

1.  析构函数，没有返回值也不写void
2.  函数名称与类名相同,在名称前加上符号 ~
3.  析构函数不可以有参数，因此不可以发生重载
4.  程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次
**即类名是对构造函数与析构函数的一个标识;
# 构造函数的调用
* 调用无参构造函数,声明类的对象时自动调用,不加( );如果加了,反而会被认为是在生明函数
* 调用有参函数,三种方法
	* 括号法,定义对象时,直接在括号内传入参数,如Person p1(10);
	* 显示法,使用等号,如Person p2 = Person(10); 
	* 隐式法,省略括号和等号,直接赋参数给对象,如
	  Person p4 = 10; // Person p4 = Person(10); 
	  Person p5 = p4; // Person p5 = Person(p4);
	注意:如果你想用一个已经存在的对象来初始化一个匿名对象(不给对象名,但实例一个对象并初始化)，不能这样写: Person p5(p4);，这样是创建了一个命名对象p5,直接使用Person(p4)即可,匿名对象只在创建时可以使用,后续由于无名字,无法继续使用,用于存储临时数据或作为函数参数使用
* **类中至少有的三种构造(析构函数)
	* 1．默认构造函数(无参，函数体为空)
	* 2．默认析构函数(无参，函数体为空)
	* 3．默认拷贝构造函数，对属性进行值拷贝
	* 其中拷贝构造函数的调用时机有:
		C++中拷贝构造函数调用时机通常有三种情况
		* 使用一个已经创建完毕的对象来初始化一个新对象，例如 Person p1(p2);，这时会调用拷贝构造函数来把p2的数据复制给p1。
		* 值传递的方式给函数参数传值，例如 void func(Person p)，这时会调用拷贝构造函数来把实参的数据复制给形参p。
		* 以值方式返回局部对象，例如 Person func()，这时会调用拷贝构造函数来把局部对象的数据复制给返回值。
# 深拷贝与浅拷贝
* 浅拷贝和深拷贝是针对引用数据类型(指的是**对象**或**数组**这样的复合数据结构。引用数据类型的变量(变量名)存储的是对象或数组在内存中的**地址**，而不是实际的值。)的拷贝方式。
  
* 例如，有一个类Person，其中有一个成员变量name，是一个字符串类型。如果我们用浅拷贝来复制一个Person对象p1，得到一个新的Person对象p2，那么p2的name变量和p1的name变量指向同一个字符串对象。如果我们修改p2的name变量，那么p1的name变量也会跟着改变。
  如果我们用深拷贝来复制一个Person对象p1，得到一个新的Person对象p2，那么p2的name变量和p1的name变量指向不同的字符串对象。如果我们修改p2的name变量，那么p1的name变量不会受到影响。
  
  解析:对象名p1,p2实际储存的都是其数据在堆区的地址,创建p1,p2都会在堆区开辟一份空间,p1,p2之间赋值,实际是堆区成员间赋值,对基本类型成员,如int,它内存中储存的就是实际值,直接"="赋值即可,而对引用类型成员,如上述的name变量,实质上储存的是一个指针,指向字符串,直接赋值,赋的是字符串的地址,而非赋值了字符串本身,p1,p2的name成员共用(或者说指向)同一份内存(即字符串所在内存),改变其中一个,会影响另一个,对这类变量,需单独为其开辟空间,再进行赋值操作,实现深拷贝


补充:基本类型：就是值类型，即在变量所对应的内存区域存储的是值，如：上面的age变量所对应的内存存储的就是值250.
引用类型,变量存储的是地址,而地址对应空间存储的才是真正的数据
由于基本类型变量存储的就是值,因此基本类型之间赋值就是直接复制值就行了
而引用类型就会产生深浅拷贝的概念


深拷贝的实现:利用new操作符,开辟空间
```C++
Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}
```
* 代码解释:利用new操作符开辟了一块int大小空间,并用\*p.m_height即p.m_height指向空间的值给这块新空间赋值,再将新空间的地址传给m_height
*注:此处m_height为指针类型变量
重复释放内存问题,即浅拷贝得到的变量与原变量共用一块地址,在析构函数运行后,相应地址会被清理两次,可能产生问题
编译器默认提供的拷贝函数是浅拷贝,拷贝函数编写都是通过操作符访问成员加赋值方式*
# 初始化列表
例:
```C++
////传统方式初始化
	//Person(int a, int b, int c) {
	//	m_A = a;
	//	m_B = b;
	//	m_C = c;
	//}

	//初始化列表方式初始化
	Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
	```
	**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`
	其中,属性对应成员变量若为可赋值变量,则直接赋值,如果是类对象,则调用其构造函数,并将相应参数传递给构造函数.
	初始化列表也可以在除构造函数外的其他函数使用,初始化列表与简单赋值的区别:初始化列表相当于声明或强调了初始化这一过程,对一些只能初始化,不能赋值的量,如const修饰的量用初始化列表可进行赋值,对对象来说,初始化就是调用其构造函数,因而初始化列表可以对对象调用构造函数
# 类对象作为类成员
C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员
	*假设a为A类对象,b为B类对象,a为B类的对象成员,在声明b时,构造函数与析构函数调用顺序一定是先调用a构造,再调用b构造,先调用b析构,再调用a析构,以此类推*    (保证b初始化完成前,a正常初始化完成,而对b析构即包含了析构a)
要给a的构造函数传参,可以
	1. **在class B的定义中,给 A a的成员声明直接带上参数进行初始化,A a(参数);**
	2. **在class B的构造函数中,添加赋给a的参数,并使用初始化列表对a赋参数,从而调用a的构造函数**
注意:**在对b初始化时(或之前),必须对a进行初始化,如果a构造函数无参,则无需自行调用构造函数,编译器会自动初始化,但如果构造函数含参时,必须通过上述两种方式之一传参调用构造函数,对a初始化**,否则会因为a未初始化报错.
# 静态成员
静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

-   静态成员变量
    -   所有对象共享同一份数据
    -   在编译阶段分配内存
    -   类内声明，类外初始化
-   静态成员函数
    -   所有对象共享同一个函数
    -   静态成员函数只能访问静态成员变量
解释:
1. **静态成员变量**在编译阶段分配内存空间，不需要在对象创建时分配内存，因此它们不占用对象的内存空间。
2.  静态成员变量在类的声明中定义，用static关键字声明,如*static int m_A*,但是在类外面进行初始化。==初始化时需要使用作用域分辨符来指定它们所属的类，例如Person::m_A = 10==(tips:类内函数类外实现也要加上作用域标识符);。
3.  静态成员变量被所有类的对象共享，即它们是所有对象的公共属性，所有对象都可以访问同一份数据。因此，如果一个对象修改了静态成员变量的值，那么这个值将会被所有其他对象共享。
4.  静态成员变量也可以拥有访问权限，即它们可以声明为私有的，只有类的成员函数才能访问它们。
解释:
-   **静态成员函数**是类的一部分，与类本身相关联，而不是与类的对象相关联。
-   静态成员函数在内存中只有一份，它被所有对象共享。
-   **静态成员函数只能访问静态成员变量，以及静态成员函数不能访问非静态成员变量及成员函数,因为非静态成员变量是与对象相关联的。**
-  **静态成员函数可以被类名直接调用，也可以被对象调用。规范做法是类名::函数名来调用.(注意:静态成员函数才可以用这种方式,成员函数不属于类,属于对象,必须通过对象来调用.)**
- 静态成员函数在类中用static关键字声明,可在类中定义,也可在类外定义,[在类外定义要注意,不能加static,并且要用类名::来标识]==(本质上,声明一个具有永久生命周期的变量)==
# 对象模型和this指针
成员变量和成员函数分开存储;只有非静态成员变量才属于对象,其他属于类,类创建的对象通用
Q: 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码,那么问题是：这一块代码是如何区分那个对象调用自己的呢？
A: **this指针
-   当形参和成员变量同名时，可用this指针来区分
-   在类的非静态成员函数中返回对象本身，可使用return *this*
解释:this指针是一个无需手动定义的,每个非静态成员函数都有一个隐式的this指针,指向成员函数所属的对象,因为其是指针,遵循指针用法,例:
```C++
class Person
{
public:

	Person(int age)
	{
		//1、当形参和成员变量同名时，可用this指针来区分
		this->age = age;
	}

	Person& PersonAddPerson(Person p)
	{
		this->age += p.age;
		//返回对象本身
		return *this;
	}

	int age;
};
```
注:this指针和对象相关联,而静态成员变量和静态成员函数都是与类相关联,不与对象相关,因此静态成员函数没有this指针,this指针也不能访问静态成员变量.
this指针可访问的是非静态成员变量和成员函数.
# 空指针调用成员函数
创建一个person类
```C++
class Person {
public:

	void ShowClassName() {
		cout << "我是Person类!" << endl;
	}

	void ShowPerson() {
		if (this == NULL) {
			return;
		}
		cout << mAge << endl;
	}
```
在不创建类的对象的情况下,如何调用类中的函数?
可以使用空指针
```C++
void test01()
{
	Person * p = NULL;
	p->ShowClassName(); //空指针，可以调用成员函数
	p->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了
}
```
创建类的空指针时,由于并没有对类实例化,因此不存在指向对象的this指针,如果类的成员函数有用到this指针的,就要先对其进行判断,是否为空指针.
# const修饰成员函数与对象
**常函数**
	*   成员函数==**后加const**==后我们称为这个函数为**常函数**
```cpp
返回类型 类名::函数名(参数列表) const {
// 函数体
}
```
	-   常函数内不可以修改成员属性
	-   成员属性声明时加关键字mutable后，在常函数中依然可以修改
	-   常函数的this指针类型为const 类名 * const 型,即指向常量对象的常指针.
**常对象：**
	-   声明对象前加const称该对象为常对象
	-   常对象只能调用常函数
	-   常对象的数据成员不允许修改,当然,加了mutable的成员可以被修改,不能修改,不代表不能初始化,常对象创建时,还是会调用构造函数,因为构造函数是非常函数,可以对数据成员修改,但一旦初始化完成后,由于常对象只能调用常函数,因此无法再对数据成员进行修改
# 友元
友元的目的就是让一个函数或者类 访问另一个类中私有成员

友元的关键字为 friend

友元的三种实现

-   全局函数做友元
-   类做友元
-   成员函数做友元

友元函数是
定义在类外部的普通函数，
但它需要在类体内进行声明
在声明时前面加以关键字friend,friend声明在哪个类,就代表友元可以访问到哪个类的私有成员。
友元函数可以是全局函数、其他类的成员函数或者其他类的友元函数。友元关系不能被继承和传递。
友元类是指在一个类中，可以访问另一个类的私有成员。使用方法和友元函数类似，只需要在类中声明友元类即可。
1.  全局函数作友元

```C++
class House {
    friend void g_canVisit(House *pHouse);
private:
    string bedroom;
public:
    string livingroom;
    House();
};

void g_canVisit(House *pHouse) {
    cout << "正在访问：" << pHouse->livingroom << endl;
    cout << "正在访问：" << pHouse->bedroom << endl;
}
```

2.  类作友元

```C++
class House;

class Family {
private:
    House* pHouse;
public:
    Family();
    void canVisit();
};

class House {
    friend class Family;
private:
    string bedroom;
public:
    string livingroom;
    House() {
        livingroom = "客厅";
        bedroom = "卧室";
    }
};

Family::Family() {
    pHouse = new House;
}

void Family::canVisit() {
    cout << "正在访问：" << pHouse->livingroom << endl;
    cout << "正在访问：" << pHouse->bedroom << endl;
}
```

3.  成员函数作友元

```C++
class House;

class Family {
private:
    House *pHouse;
public:
    Family();
    void canVisit();
    void canNotVisit();
};

class House {
    friend void Family::canVisit();
private:
    string bedroom;
public:
    string livingroom;
    House() {
        this->livingroom = "客厅";
        this->bedroom = "卧室";
    }
};

Family::Family() {
    pHouse = new House;
}

void Family::canVisit() {
    cout << "正在访问：" << pHouse->livingroom << endl;
    cout << "正在访问：" << pHouse->bedroom << endl;
}

void Family::canNotVisit() {
    cout << "正在访问：" << pHouse->livingroom << endl;
}
```
友元访问类的私有成员一般的实现方法
* 对函数来说,可以将形参设为对应友元类的拷贝或指针,通过拷贝或指针对该类成员直接访问
* 对类来说,通过类的成员或成员函数去访问友元类,比如,声明一个友元类类型的指针成员,或者声明一个成员函数,形参是......

友元的声明不需要在public或private下声明，因为它们对于访问说明符没有影响。友元可以出现在类中的任何地方，通常被成批地放在类定义的开始或结尾。友元的作用是让一个函数或类可以访问另一个类中的私有或受保护成员。